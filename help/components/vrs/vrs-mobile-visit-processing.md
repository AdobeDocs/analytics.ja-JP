---
description: 仮想レポートスイートのコンテキスト対応セッションは、Adobe Analytics によるモバイル訪問数の計算方法を変更します。この記事では、（モバイル SDK によって設定される）バックグラウンドヒットとアプリ起動イベントの処理がモバイル訪問数の定義にどのように影響するかについて説明します。
title: コンテキスト対応セッション
uuid: d354864a-9163-4970-a3a0-f2e9729bdbe3
translation-type: tm+mt
source-git-commit: 3997889ae72920d719203edbb159b55b983158e7

---


# コンテキスト対応セッション

仮想レポートスイートのコンテキスト対応セッションは、Adobe Analyticsがどのデバイスからの訪問を計算するかを変更します。 また、バックグラウンドヒットとアプリの起動イベント（両方ともモバイルSDKによって設定）の処理上の影響を、モバイル訪問の定義方法に説明します。

訪問は、基礎となるデータを変更することなく、任意の方法で定義し、訪問者がデジタルエクスペリエンスとやり取りする方法に合わせて設定できます。

## 顧客パースペクティブURLパラメーター

Adobe Analyticsのデータ収集プロセスでは、顧客の視点(「cp」クエリ文字列パラメーターとして示される)を指定するクエリ文字列パラメーターを設定できます。 このフィールドは、エンドユーザーのデジタルアプリケーションの状態を指定します。 これは、モバイルアプリがバックグラウンド状態のときにヒットが生成されたかどうかを知るのに役立ちます。

## バックグラウンドヒットの処理

バックグラウンドヒットは、バックグラウンド状態の間にアプリがトラッキングリクエストを行ったときに、Adobe Mobile SDKバージョン4.13.6以降からAnalyticsに送信されるヒットの一種です。 このような例を次に示します。

* ジオフェンスの横断中に送信されたデータ
* プッシュ通知インタラクション

次の例は、仮想レポートスイートで「バックグラウンドヒットによる新しい訪問の開始を防ぐ」設定が有効または無効の場合に、訪問開始をいつ決定し、訪問者で終了するかを決定するロジックを示しています。

**「バックグラウンドヒットで新しい訪問が開始されないようにする」が有効になっていない場合：**

この機能が仮想レポートスイートで有効になっていない場合、バックグラウンドヒットは他のヒットと同じように扱われ、新しい訪問が開始され、フォアグラウンドヒットと同じように動作します。 例えば、バックグラウンドヒットが30分（レポートスイートの標準のセッションタイムアウト）未満で発生した場合、バックグラウンドヒットはセッションの一部となります。

![](assets/nogood1.jpg)

バックグラウンドヒットがフォアグラウンドヒットの30分以上前に発生した場合、バックグラウンドヒットは、合計訪問回数2の独自の訪問を作成します。

![](assets/nogood2.jpg)

**「バックグラウンドヒットで新しい訪問が開始されないようにする」が有効になっている場合：**

次の例は、この機能が有効になっているときのバックグラウンドヒットの動作を示しています。

例 1：バックグラウンドヒットが発生してから一定時間（t）が経って一連のフォアグラウンドヒットが発生したとします。

![](assets/nogoodexample1.jpg)

この例では、 *tが* 、仮想レポートスイートで設定されている訪問のタイムアウトを超える場合、バックグラウンドヒットは、フォアグラウンドヒットによって形成される訪問から除外されます。 例えば、仮想レポートスイートの訪問のタイムアウトが15分に設定され、 *tが* 20分だった場合、この一連のヒット（緑の輪郭で示される）によって形成される訪問によってバックグラウンドヒットが除外されます。 つまり、バックグラウンドヒットで「訪問」の有効期限が設定されたeVarは、次の訪問まで持続せず **** 、訪問セグメントコンテナには緑色のアウトライン内のフォアグラウンドヒットのみが含まれます。

![](assets/nogoodexample1-2.jpg)

逆に、 *tが* 、仮想レポートスイートの設定された訪問のタイムアウトより小さい場合、バックグラウンドヒットは、フォアグラウンドヒット（緑色のアウトラインで示される）のように訪問の一部として含まれます。

![](assets/nogoodexample1-3.jpg)

これは、次のことを意味します。

* バックグラウンドヒットで「訪問」の有効期限が設定されたeVarは、その値をこの訪問の他のヒットに保持します。
* バックグラウンドヒットに設定された値は、訪問レベルのセグメントコンテナロジック評価に含まれます。

どちらの場合も、合計訪問回数は1になります。

例 2：一連のフォアグラウンドヒットが発生した後にバックグラウンドヒットが発生した場合の動作は次のようになります。

![](assets/nogoodexample2.jpg)

仮想レポートスイートの設定がタイムアウトした後にバックグラウンドヒットが発生した場合、バックグラウンドヒットはセッションの一部ではありません（緑色で概要が示されています）。

![](assets/nogoodexample2-1.jpg)

同様に、時間枠 *tが* 、仮想レポートスイートの設定されたタイムアウトよりも短い場合、バックグラウンドヒットは、以前のフォアグラウンドヒットで形成された訪問に含まれます。

![](assets/nogoodexample2-2.jpg)

これは、次のことを意味します。

* 以前のフォアグラウンドヒットで「訪問」の有効期限が切れて設定されたeVarは、その値をこの訪問のバックグラウンドヒットに保持します。
* バックグラウンドヒットに設定された値は、訪問レベルのセグメントコンテナロジック評価に含まれます。

以前と同様に、どちらの場合も合計訪問回数は1になります。

例 3：状況により、バックグラウンドヒットの発生によって 2 つの訪問が 1 つの訪問にまとめられる場合があります。次のシナリオでは、バックグラウンドヒットの前後に、一連のフォアグラウンドヒットが続きます。

![](assets/nogoodexample3.jpg)

この例では、 *t1* とt2の両方が、設定された仮想レポートスイートの訪問タイムアウトよりも小さい場合、 *t1***** とt2の合計が訪問タイムアウトより大きい場合でも、これらのヒットはすべて単一の訪問に結合されます。

![](assets/nogoodexample3-1.jpg)

ただし、 *t1* と *t2* が設定された仮想レポートスイートのタイムアウトより大きい場合、これらのヒットは2つの異なる訪問に分割されます。

![](assets/nogoodexample3-2.jpg)

同様に（前の例のように）、 *t1* がタイムアウトより小さく、 ** t2がタイムアウトより小さい場合、バックグラウンドヒットは最初の訪問に含まれます。

![](assets/nogoodexample3-3.jpg)

t1 *がタイム* アウトより大きく、 ** t2がタイムアウトより小さい場合、バックグラウンドヒットは2回目の訪問に含まれます。

![](assets/nogoodexample3-4.jpg)

例 4：仮想レポートスイートで設定されている訪問タイムアウト期間内に一連のバックグラウンドヒットが発生した場合、バックグラウンドヒットは目に見えない「バックグラウンド訪問」を形成します。これらの訪問は訪問数にカウントされず、訪問セグメントコンテナを使用してアクセスすることもできません。

![](assets/nogoodexample4.jpg)

バックグラウンド訪問は訪問と見なされませんが、訪問の有効期間が設定された eVar の値は同じ「バックグラウンド訪問」で発生した他のバックグラウンドヒットにも引き継がれます。

例 5：一連のフォアグラウンドヒットが発生した後に複数のバックグラウンドヒットが連続して発生した場合、（タイムアウト設定によって異なりますが）それらのバックグラウンドヒットにより訪問タイムアウト期間を越えて 1 つの訪問が継続されることがあります。例えば、 *t1* と *t2* を合わせた値が仮想レポートスイートの訪問のタイムアウト値よりも大きいが、個別にタイムアウト値よりも小さい場合、訪問は継続して、両方のバックグラウンドヒットを含むようになります。

![](assets/nogoodexample5.jpg)

同様に、一連のバックグラウンドヒットが一連のフォアグラウンドイベントの前に発生した場合も、同様の動作が発生します。

![](assets/nogoodexample5-1.jpg)

バックグラウンドヒットは、バックグラウンドヒット時に設定されたeVarや他の変数からのアトリビューション効果を保持するために、このように動作します。 これにより、ダウンストリームのフォアグラウンドコンバージョンイベントは、アプリがバックグラウンド状態のときに実行されたアクションに関連付けられます。 また、訪問セグメントコンテナに、ダウンストリームフォアグラウンドセッションに結び付いたバックグラウンドヒットを含めることもできます。これは、プッシュメッセージの効果を測定するのに役立ちます。

## 訪問指標の動作

訪問回数は、少なくとも1つのフォアグラウンドヒットを含む訪問の数にのみ基づきます。 つまり、孤立したバックグラウンドヒットや「バックグラウンド訪問」は、訪問指標にカウントされません。

## 訪問別滞在時間指標の動作

滞在時間は、ヒット間の時間を使用して、バックグラウンドヒットなしの場合と同様に計算されます。 ただし、訪問にバックグラウンドヒットが含まれる場合（前景ヒットに近い程度に発生したため）、それらのヒットは、前景ヒットであるかのように、訪問別の計算に含まれます。

## バックグラウンドヒット処理の設定

バックグラウンドヒットの処理はレポート時間処理を使用している仮想レポートスイートでしか利用できないので、Adobe Analytics では、レポート時間処理を使用しないベースレポートスイートでも訪問数を維持できるように、2 種類のバックグラウンドヒット処理がサポートされています。この設定にアクセスするには、Adobe Analytics管理コンソールに移動し、該当するベースレポートスイートの設定に移動し、「モバイル管理」メニューに移動して、「モバイルアプリレポート」サブメニューに移動します。

1. 「レガシー処理オン」:これは、すべてのレポートスイートのデフォルト設定です。 プロセスのバックグラウンドヒットに対する既存の処理を、レポート時間アトリビューションベース以外のレポートスイートに関しては、処理パイプラインの通常のヒットとして残すことが重要です。 つまり、ベースレポートスイートに表示されるバックグラウンドヒットは、通常のヒットとして訪問回数を増分します。 バックグラウンドヒットをベースレポートスイートに表示しない場合は、この設定を「オフ」に変更します。
1. 「レガシー処理オフ」:バックグラウンドヒットの従来の処理がオフの場合、ベースレポートスイートに送信されたバックグラウンドヒットはベースレポートスイートで無視され、このベースレポートスイートで作成された仮想レポートスイートがレポート時間処理を使用するように設定されている場合にのみアクセスできます。 つまり、このベースレポートスイートに送信されたバックグラウンドヒットによってキャプチャされたデータは、レポート時間処理が有効な仮想レポートスイートにのみ表示されます。

   この設定は、ベースレポートスイートの訪問回数を変更せずに、新しいバックグラウンドヒット処理を利用したいお客様を対象としています。

どちらの場合も、バックグラウンドヒットは、Analyticsに送信された他のヒットと同じ費用で請求されます。

## 各アプリの起動時に新しい訪問を開始

バックグラウンドヒット処理に加えて、仮想レポートスイートは、モバイルSDKがアプリの起動イベントを送信するたびに、開始を強制的に新たに訪問する可能性があります。 この設定を有効にすると、SDKからアプリの起動イベントが送信された場合、開いている訪問がタイムアウトに達したかどうかに関係なく、開始に新しい訪問が強制的に送信されます。 アプリの起動イベントを含むヒットは、次の訪問の最初のヒットとして含まれ、訪問回数が増分され、セグメント化のための個別の訪問コンテナが作成されます。
