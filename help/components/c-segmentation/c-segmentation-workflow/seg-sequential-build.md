---
description: 順次セグメントは、AND や OR ではなく、THEN 演算子を使用して作成されます。THEN は、1 つのセグメント条件が発生すると、もう 1 つのセグメント条件が続くことを示します。デフォルトでは、順次セグメントは、フィルター「全員を含む」を表示し、合致するすべてのデータを識別します。順次セグメントは、「シーケンスの前のみ」および「シーケンスの後のみ」オプションを使用して、さらに合致するヒットのサブセットにフィルタリングできます。
seo-description: 順次セグメントは、AND や OR ではなく、THEN 演算子を使用して作成されます。THEN は、1 つのセグメント条件が発生すると、もう 1 つのセグメント条件が続くことを示します。デフォルトでは、順次セグメントは、フィルター「全員を含む」を表示し、合致するすべてのデータを識別します。順次セグメントは、「シーケンスの前のみ」および「シーケンスの後のみ」オプションを使用して、さらに合致するヒットのサブセットにフィルタリングできます。
seo-title: 順次セグメントの作成
solution: Analytics
title: 順次セグメントの作成
topic: セグメント
uuid: 7fb9f1c7- a738-416a- aaa2- d77e40fa7e61
translation-type: tm+mt
source-git-commit: b21f741216af8edc631cc271618f638d46a16a96

---


# 順次セグメントの作成

順次セグメントは、AND や OR ではなく、THEN 演算子を使用して作成されます。THEN は、1 つのセグメント条件が発生すると、もう 1 つのセグメント条件が続くことを示します。デフォルトでは、順次セグメントは、フィルター「全員を含む」を表示し、合致するすべてのデータを識別します。順次セグメントは、「シーケンスの前のみ」および「シーケンスの後のみ」オプションを使用して、さらに合致するヒットのサブセットにフィルタリングできます。

![](assets/before-after-sequence.png)

さらに、特定の期間、精度およびチェックポイント間のカウントに順次セグメントを制限することができます。それには、[After および Within 演算子](../../../components/c-segmentation/c-segmentation-workflow/seg-sequential-build.md#concept_07708877D06742998C6237DD9FD194EA)を使用します。

## 全員を含む {#section_75ADDD5D41F04800A09E592BB2940B35}

「全員を含む」が設定されているセグメントを作成すると、そのセグメントでは指定されたパターン全体と一致するパスを識別します。これは、同じ訪問者が訪問したときのヒット（ページ A）に続くヒット（ページ B）を探す基本的なシーケンスセグメントの例です。セグメントを「全員を含む」に設定します。

![](assets/sequence-filter.png)

| 結果の場合… | シーケンス |
|--- |--- |
| 一致する | A then B<br>A then (in a different visit) B<br>A then D then B |
| 一致しない場合 | B -&gt; A |

## シーケンスの前のみおよびシーケンスの後のみ {#section_736E255C8CFF43C2A2CAAA6D312ED574}

「**[!UICONTROL シーケンスの前のみ]**」および「**シーケンスの後のみ[!UICONTROL 」オプションは、セグメントを特定のシーケンスの前または後のデータのサブセットにフィルタリングします。]**

* **シーケンスの前のみ**：シーケンスの前のすべてのヒットおよびシーケンス自体の最初のヒットが含まれます（例 1、3 を参照）。1 つのパスにシーケンスが複数回現れる場合、「シーケンスの前のみ」には、最後のシーケンスの最初のヒットおよびそれ以前のすべてのヒットが含まれます（例 2 を参照）。
* **シーケンスの後のみ**：シーケンスの後のすべてのヒットおよびシーケンス自体の最後のヒットが含まれます（例 1、3 を参照）。1 つのパスにシーケンスが複数回現れる場合、「シーケンスの後のみ」には、最初のシーケンスの最後のヒットおよびそれ以後のすべてのヒットが含まれます（例 2 を参照）。

例えば、B -&gt; D のシーケンスについて考えてみます。3 つのフィルターは、次のようにヒットを識別します。

**例 1：B の次に D が 1 回現れる**

| 例 | A | B | C | D | E | F |
|---|---|---|---|---|---|---|
| 全員を含む | A | B | C | D | E | F |
| シーケンスの前のみ | A | B |  |  |  |  |
| シーケンスの後のみ |  |  |  | D | E | F |

**例 2：B の次に D が複数回現れる**

| 例 | A | B | C | D | B | C | D | E |
|---|---|---|---|---|---|---|---|---|
| 全員を含む | A | B | C | D | B | C | D | E |
| シーケンスの前のみ | A | B | C | D | B |  |  |  |
| シーケンスの後のみ |  |  |  | D | B | C | D | E |

また、この概念をヒットの深さディメンションに当てはめてみましょう。

**例 3：ヒットの深さ 3 の後に 5**

![](assets/hit-depth.png)

## ディメンション制約 {#section_EAFD755F8E674F32BCE9B642F7F909DB}

「within」句の「THEN」ステートメントの間に、たとえば「within 1 search keyword instance（1 個の検索キーワードのインスタンス内）」や「within 1 eVar 47 instance（1 個の eVar 47 インスタンス内）」というように追加できます。これにより、ディメンションの 1 個のインスタンス内にセグメントが制限されます。

ルールの間に「Within ディメンション」句を設定したセグメントでは、その句を満たすシーケンスにデータを制限できます。制約が「Within 1 page（1 ページ内）」に設定されている以下の例を参照してください。

![](assets/sequence-filter4.png)

| 結果の場合… | シーケンス |
|--- |--- |
| 一致する | A -&gt; B |
| 一致しない場合 | A then C then B (because B was not within 1 page of A)<br>**Note:**  If the dimension restriction is taken out, "A then B" and "A then C then B" would both match. |

## 単純なページビューシーケンス

あるページを閲覧した後に別のページを閲覧した訪問者を識別します。以前、過去または中間の訪問セッションまたは間に発生したページビューの時間や数に関係なく、ヒットレベルのデータによって、このシーケンスがフィルターされます。

****&#x200B;例:訪問者がページAを閲覧した後、同じまたは別の訪問でページBを閲覧した。

**使用例**

次に、セグメントの使用例を示します。

1. スポーツサイトの訪問者がフットボールランディングページを閲覧し、その後、バスケットボールランディングページを閲覧しますが、必ずしも同じ訪問であるとは限りません。これは、フットボールシーズン中のフットボールの閲覧者にバスケットボールに関するコンテンツをプッシュするようにキャンペーンに促します。
1. ある自動車小売店では、顧客の忠誠度ページをランディングページとして閲覧し、その後、同じ訪問または別の訪問でビデオページに移動した訪問者間の関係を識別します。

**このセグメントを作成**

2 つのページルールをトップレベルの[!UICONTROL 訪問者]コンテナ内でネストし、[!UICONTROL THEN] 演算子を使用してページヒットを順番に並べます。

![](assets/segment_sequential_1.png)

## 訪問にわたる訪問者シーケンス

キャンペーンからフォールアウトしたが、別のセッションでこのページビューのシーケンスに戻ってきた訪問者を識別します。

****&#x200B;例:訪問者は1回の訪問でページAを閲覧し、その後別の訪問でページBを閲覧した。

**ユースケース**

次に、このタイプのセグメントの使用例を示します。

* ニュースサイトのスポーツページを訪問した後、別のセッションでスポーツページを再度訪問します。
* ある衣料品店では、あるセッションでランディングページを閲覧し、さらに、別のセッションでチェックアウトページに直接移動した訪問者間の関係を表示します。

**このセグメントを作成**

この例では、2 つの&#x200B;**[!UICONTROL 訪問]**&#x200B;コンテナをトップレベルの&#x200B;**[!UICONTROL 訪問者]コンテナ内でネストし、[!UICONTROL THEN]演算子を使用してセグメントを順に並べます。**

![](assets/visitor_seq_across_visits.png)

## 混合レベルシーケンス

不明な訪問回数の間に 2 つのページを閲覧し、さらに別の訪問で 3 ページ目を閲覧した訪問者を識別します。

****&#x200B;例:訪問者は1回以上の訪問でページAとページBを訪問し、その後別の訪問でページCに訪問します。

**ユースケース**

次に、このタイプのセグメントの使用例を示します。

* 訪問者は、最初にニュースサイトを訪問した後、同じ訪問でスポーツページを閲覧します。さらに、別の訪問でウェザーページを訪問します。
* ある小売店では、メインページの後にマイアカウントページに入る訪問者を定義します。さらに、これらの訪問者は、別の訪問でカートを表示ページを訪問します。

**このセグメントを作成**

1. 左のパネルからトップレベルの「[!UICONTROL 訪問者]」コンテナ内に 2 つのページディメンションをドロップします。
1. これらのページディメンション間に THEN 演算子を追加します。
1. **[!UICONTROL オプション]** /コンテナ **** を追加をクリックし、訪問者レベルの下に [!UICONTROL 訪問] コンテナ [!UICONTROL を追加] して [!UICONTROL 、THEN] 演算子を使用して順番に並べます。

![](assets/mixed_level_checkpoints.png)

## 集計コンテナ

[!UICONTROL 訪問者]コンテナ内に[!UICONTROL ヒット]コンテナを複数追加すると、同じタイプのコンテナの間に適切な演算子を使用できます。また、ページ数や訪問回数などのルールやディメンションを使用して、ページビューを定義し、[!UICONTROL ヒット]コンテナ内に順次ディメンションを指定することもできます。ヒットレベルでロジックを適用すると、[!UICONTROL 訪問者]コンテナ内で一致した同じレベルのヒットを制限および組み合わせて、様々なタイプのセグメントを作成できます。

**例**：ページビューのシーケンスの最初のヒット（この例ではページ D）の後で、訪問者がページ A を訪問してから、ページ B またはページ C のいずれかを訪問した（訪問回数は不問）。

**ユースケース**

次に、このタイプのセグメントの使用例を示します。

* ある訪問でメインランディングページを訪問し、次の訪問で男性衣料品ページを閲覧し、さらに次の訪問で女性または子供のランディングページを閲覧した訪問者を識別します。
* e-zine で、ある訪問でホームページを閲覧し、次の訪問でスポーツページを閲覧し、さらに次の訪問でオピニオンページを閲覧した訪問者を収集します。

**このセグメントを作成**

1. [!UICONTROL 訪問者]コンテナを、トップレベルのコンテナとして選択します。
1. 2 つの[!UICONTROL ヒット]レベルのコンテナを追加します。このとき、ディメンションには、[!UICONTROL AND] や [!UICONTROL OR] 演算子によって同じ[!UICONTROL ヒット]レベルで結合された適切な数値ディメンションを含めます。
1. 同じ[!UICONTROL 訪問]コンテナ内に、別の[!UICONTROL ヒット]コンテナを追加し、[!UICONTROL OR] または [!UICONTROL AND] 演算子で結合された 2 つの追加の[!UICONTROL ヒット]コンテナをネストします。

   [!UICONTROL THEN] 演算子を使用して、ネストされた[!UICONTROL ヒット]コンテナのシーケンスを作成します。

![](assets/aggregate_checkpoints2.png)

## 順次セグメントでの「ネスト」

[!UICONTROL 訪問]と[!UICONTROL ヒット]の両方のレベルでチェックポイントを配置することで、特定の訪問に加えて特定のヒット内の要件も満たすようにセグメントに制約をかけることができます。

****&#x200B;例:訪問者はページAを訪問し、同じ訪問でページBを訪問した。さらに別の訪問でページ C にアクセスした。

**このセグメントを作成**

1. トップレベルの[!UICONTROL 訪問]コンテナで、2 つのページディメンションをドラッグします。
1. Multi-select both rules, click **[!UICONTROL Options]** &gt; **[!UICONTROL Add container from selection]** and change it to a [!UICONTROL Visit] container.
1. これらのルールを [!UICONTROL THEN] 演算子で結合します。
1. [!UICONTROL 訪問]コンテナのピアとしてヒットコンテナを作成し、ページディメンションをドラッグします。
1. 別の [!UICONTROL THEN] 演算子を追加して、[!UICONTROL 訪問]コンテナ内のネストされたシーケンスを、[!UICONTROL ヒット]コンテナと結合します。

![](assets/nesting_sequential_seg.png)

## ヒットの除外

「[!UICONTROL 以下を除外する]」ルールを使用して[!UICONTROL 訪問者]、[!UICONTROL 訪問]または[!UICONTROL ヒット]のデータを明示的に除外しない限り、セグメントルールはすべてのデータを含みます。「以下を除外する」ルールは、一般的なデータを無視して、より焦点を絞ったセグメントを作成するために使用できます。また、検索されたグループを除外するセグメントを作成して、それ以外のデータセットを識別するためにも使用できます。例えば、注文をした成功訪問者を含めたルールを作成した後に成功訪問者を除外することで「非購入者」を識別するという方法が考えられます。ただし、ほとんどの場合は、特定の値を含む対象を識別するために「[!UICONTROL 以下を除外する]」ルールを使用するよりも、広範な値を除外するルールを作成する方が良いでしょう。

以下に例を示します。

* **ページの除外**。セグメントルールを使用して特定のページ（*`Home Page`*) レポートから、ページが「ホームページ」に等しいヒットルールを作成し、除外します。このルールにより、ホームページを除くすべての値が自動的に含まれるようになります。
* **参照ドメインの除外**。Google.com からの参照ドメインのみ含み、その他のすべての参照ドメインを除外するルールを使用します。
* **非購入者の識別**。注文件数が 1 以上の場合を識別して、その[!UICONTROL 訪問者]を除外します。

[!UICONTROL Exclude] 演算子を使用して、特定の訪問またはヒットが訪問者によって実行されないシーケンスを識別できます。[!UICONTROL 除外チェックポイント]も [論理グループ](../../../components/c-segmentation/c-segmentation-workflow/seg-sequential-build.md#concept_23CE0E6071E14E51B494CD21A9799112).

## チェックポイント間の除外

あるチェックポイントが他の 2 つチェックポイント間で明示的に発生しなかった場合に訪問者をセグメント化する論理を強制します。

****&#x200B;例:ページAを訪問し、ページCを訪問したが、ページBは訪問しなかった訪問者。

**ユースケース**

次に、このタイプのセグメントの使用例を示します。

* ライフスタイルページの後、アートページに行かずに、シアターセクションを訪問した訪問者。
* ある自動車販売店では、メインランディングページの後、車両ページに行かずに、キャンペーンに興味なしページに直接移動した訪問者間の関係を表示します。

**このセグメントを作成**

Create a segment as you would for a simple, mixed-level, or nested sequential segment and then set the [!UICONTROL EXCLUDE] operator for the container element. 次の例は、集計セグメントです。ここでは、3 つの[!UICONTROL ヒット]コンテナがキャンバスにドラッグされており、コンテナ論理を結合するために [!UICONTROL THEN] 演算子が割り当てられています。その後で、シーケンス内でページ A からページ C に移動した訪問者だけを含めるために中間のページビューコンテナが除外されています。

![](assets/exclude_between_checkpoints.png)

## シーケンスの開始時の除外

除外チェックポイントが順次セグメントの最初にある場合、除外されないヒットが最初に閲覧される前に、除外されるページは閲覧されないものとして扱われます。

****&#x200B;例:訪問者がページAを訪問し、ページBではない。

**ユースケース**

次に、このタイプのセグメントの使用例を示します。

* ページ A を訪問し、ページ B を訪問しなかった訪問者。
* あるレストランでは、メインランディングページを避けて、注文ページに直接移動した常連ユーザーを表示します。

**このセグメントを作成**

トップレベルの訪問者コンテナ内に 2 つの別個のヒットコンテナを作成します。次に、最初のコンテナに対して [!UICONTROL EXCLUDE] 演算子を設定します。

![](assets/exclude_beginning_sequence.png)

## シーケンスの終了時の除外

除外チェックポイントがシーケンスの最後にある場合、訪問者シーケンスが終了するまで、除外されない最後のチェックポイントと訪問者シーケンスの最後の間でチェックポイントは発生しません。

****&#x200B;例:訪問者は、現在の訪問または後続の訪問でページAを訪問し、ページBを訪問しませんでした。

**ユースケース**

次に、このタイプのセグメントの使用例を示します。

* ページ A を訪問し、ページ B を訪問しなかった訪問者。
* あるレストランでは、メインランディングページを避けて、注文ページに直接移動した常連ユーザーを表示します。

**このセグメントを作成**

Build a simple sequence segment by dragging two [!UICONTROL Hit] containers to the canvas and connecting them using the [!UICONTROL THEN] operator. 次に、[!UICONTROL EXCLUDE] 演算子をシーケンス内の 2 番目の[!UICONTROL ヒット]コンテナに割り当てます。

![](assets/exclude_end_sequence.png)

## 論理グループコンテナ

順次セグメント内では、各コンテナが[コンテナ階層](../../../components/c-segmentation/seg-overview.md#concept_A38E7000056547399E346559D85E2551)内で厳密に順序付けられている必要があります。[!UICONTROL 論理グループ]コンテナは、順次セグメント内でより上位のコンテナが必要になる場合を想定して作成されました。これにより、訪問者をさらにフィルターして、複雑なネストされた訪問者レベルの制約を指定してセグメントを洗練できます。

| 標準的なコンテナ階層 |
|---|
| ![](assets/nesting_container.png) |
| ヒット数、訪問数および訪問者に基づいてセグメントを抽出するために、[!UICONTROL 訪問者]コンテナ内で、[!UICONTROL 訪問]コンテナと[!UICONTROL ヒット]コンテナが順次ネストされます。 |

>[!NOTE]
>
>[!UICONTROL 論理グループ] は、順次セグメントでのみ定義できます。つまり、式内で [!UICONTROL THEN] 演算子が使用されます。

[!UICONTROL 論理グループ]コンテナは、複数のチェックポイントを順番を付けずに 1 つのグループとして扱います。例えば、[!UICONTROL 訪問者]コンテナを別の[!UICONTROL 訪問者]コンテナ内にネストすることはできません。しかし、代わりに、[!UICONTROL 論理グループ]コンテナを[!UICONTROL 訪問者]コンテナ内にネストし、特定の[!UICONTROL 訪問]および[!UICONTROL ヒット]レベルのチェックポイントをそこに含めることができます。

| 論理コンテナによる標準的ではない階層 |
|---|
| ![](assets/logic_group_hierarchy.png) |
| 標準的なコンテナ階層は、[!UICONTROL 論理グループ]コンテナの外側にも必要です。ただし、[!UICONTROL 論理グループ]コンテナ内部では、チェックポイントの順序や階層を設定する必要はありません。これらのチェックポイントで必要なのは、順序を問わず、訪問者が条件を満たすことです。 |

## Build a Logic Group segment {#section_A5DDC96E72194668AA91BBD89E575D2E}

Like other containers, the [!UICONTROL Logic Group] containers can be built in multiple ways within the [!UICONTROL Segment Builder]. [!UICONTROL 論理グループ]コンテナをネストするための推奨される方法は次のとおりです。

1. 左のパネルから、ディメンション、イベントまたはセグメントをドラッグします。
1. 最上位のコンテナを「[!UICONTROL 訪問者]」コンテナに変更します。
1. デフォルトで挿入される [!UICONTROL AND] または [!UICONTROL OR] 演算子を THEN 演算子に変更します。
1. [!UICONTROL ヒット] コンテナ（ディメンション、イベントまたはアイテム）を選択し、 **[!UICONTROL オプション]** /選択範囲からコンテナ **[!UICONTROL を追加をクリック]**&#x200B;します。
1. Click the container icon and select **[!UICONTROL Logic Group]**.  ![](assets/logic_group_checkpoints.png)
1. これで、階層に関係なく、[!UICONTROL ヒット]を[!UICONTROL 論理グループ]コンテナ内に設定できました。

## 論理グループのチェックポイントの順序

[!UICONTROL 論理グループ]を使用すると、シーケンスの外部にあるそのグループ内の条件を満たすことができます。This allows you to build segments where a [!UICONTROL Visit] or [!UICONTROL Hit] container happens irrespective of the normal hierarchy.****

****&#x200B;例:ページAを訪問し、ページBとページCを任意の順序で訪問した訪問者。

**このセグメントを作成**

ページ B および C は、外部「[!UICONTROL 訪問者]」コンテナ内の「[!UICONTROL 論理グループ]」コンテナ内でネストされます。次に、A の「[!UICONTROL ヒット]」コンテナの後に、[!UICONTROL AND] 演算子を使用して識別された B と C の「[!UICONTROL 論理グループ]」コンテナが続きます。B と C は「[!UICONTROL 論理グループ]」内にあるので、シーケンスが定義されるわけではなく、ページ B または C をヒットした場合に引数は true になります。

![](assets/logic_group_any_order2.png)

## 論理グループの最初の一致

[!UICONTROL 論理グループ]を使用すると、シーケンスの外部にあるそのグループ内の条件を満たすことができます。この順不同の最初の一致セグメントでは、[!UICONTROL 論理グループ]のルールによって、最初にページビューがページ B またはページ C のどちらであるかが識別され、その後で必須のページ A のビューが識別されます。

****&#x200B;例:ページBまたはページCのいずれかを訪問した後、ページAを訪問した。

**このセグメントを作成**

ページ B とページ C のディメンションは[!UICONTROL 論理グループ]コンテナ内にグループ化されます。このコンテナでは [!UICONTROL OR] 演算子が選択されます。次に、[!UICONTROL ヒット]コンテナにページ A が値として表されます。

![](assets/logic_group_1st_match.png)

## 論理グループはANDを除外します

[!UICONTROL 論理グループ] を使用してセグメントを作成し、複数のページビューが集計されて、他のページが除外されている間にどのページがヒットされる必要があるかを定義します。****

****&#x200B;例:訪問者はページAを訪問し、ページBまたはCは明示的に訪問せず、ページDをヒットしていました。

**このセグメントを作成**

このセグメントを作成するには、左のパネルからディメンション、イベントおよび事前ビルドセグメントをドラッグします。See [Building a Logic Group Segment](../../../components/c-segmentation/c-segmentation-workflow/seg-sequential-build.md#concept_23CE0E6071E14E51B494CD21A9799112).

「[!UICONTROL 論理グループ]」内で値をネストしてから、「**[!UICONTROL 論理グループ]」コンテナ内の**[!UICONTROL 除外]ボタンをクリックします。

![](assets/logic_exclude_and.png)

## 論理グループはORを除外

[!UICONTROL 論理グループ]を使用してセグメントを作成します。このグループでは、複数のページビューを集計して、他の特定のページが除外されている間にどのページがヒットされる必要があるかを定義します。

****&#x200B;例:ページAを訪問したが、ページAの前にページBまたはページCを訪問しなかった訪問者。

**このセグメントを作成**

最初のページ B とページ C が、除外された「[!UICONTROL 論理グループ]」コンテナで識別されます。その後で、訪問者によるページ A のヒットが続きます。

このセグメントを作成するには、左のパネルからディメンション、イベントおよび事前ビルドセグメントをドラッグします。

「[!UICONTROL 論理グループ]」内で値をネストしてから、「**[!UICONTROL 論理グループ]」コンテナ内の**[!UICONTROL 除外]ボタンをクリックします。

![](assets/logic_exclude_or.png)

## タイムWithinおよびtime- afterセグメントの構築

各コンテナのヘッダーに組み込まれた [!UICONTROL Within] および [!UICONTROL After] 演算子を使用して、時間、イベントおよびカウントを定義します。

![](assets/then_within_operators.png)

[!UICONTROL Within] および [!UICONTROL After] コンテナを使用し、精度とカウントを指定することで、一致の範囲を指定した期間に制限できます。[!UICONTROL Within] 演算子は、2 つのチェックポイントの間隔の最大値を指定するために使用します。[!UICONTROL After] 演算子は、2 つのチェックポイントの間隔の最小値を指定するために使用します。

## AFTER および WITHIN 演算子 {#section_CCAF5E44719447CFA7DF8DA4192DA6F8}

期間は、精度を表す 1 つの大文字の後に、その精度の繰り返し回数を表す数値を記述して指定します。

**[!UICONTROL Within]** はエンドポイントを含みます（エンドポイント以下）。

**[!UICONTROL After]** はエンドポイントを含みません（エンドポイントを超える）。

| 演算子 | 説明 |
|--- |--- |
| AFTER | After 演算子は、2 つのチェックポイントの間隔の最小値を指定するために使用します。After 値を設定すると、セグメントの適用時にこの時間制限が開始されます。例えば、ページAを訪問したが、1日後に訪問ページBに戻らない訪問者を識別するためにコンテナに"After"演算子が設定されている場合、訪問者がページAを離れたときにその日が開始されます。訪問者がセグメントに含まれるようにするには、ページAを離れてからページBを表示した後、最低1440分（1日）が経過する必要があります。 |
| WITHIN | Within 演算子は、2 つのチェックポイントの間隔の最大値を指定するために使用します。例えば、ページAを訪問してから1日以内に訪問ページBに戻った訪問者を識別するためにコンテナに設定されているWithin演算子は、訪問者がページAを離れたときに開始します。セグメントに含めるために、訪問者はページBを開くまでに1日の最大時間を持ちます。訪問者がセグメントに含まれるためには、ページBへの訪問は、ページAを離れてからページBを閲覧した後、最大1440分（1日）以内に発生する必要があります。 |
| AFTER／WITHIN | After と Within の両方の演算子を使用する場合に重要になるのが、両方の演算子が順次的ではなく並行的に開始および終了するという点です。For example, if you build a segment with the container set to:<br>`After = 1 Week(s) and Within = 2 Week(s)`<br>Then the conditions to identify visitors in the segment are met only between 1 and 2 weeks. 最初のページヒットの時点から、両方の条件が適用されます。 |

## After演算子の使用

* After の時間では、年、月、日、時間および分を指定して、一致する訪問を追跡できます。
* After の時間は、このような細かな精度を定義できる唯一のレベルである[!UICONTROL ヒット]コンテナにのみ適用されます。

****&#x200B;例:ページAを訪問した訪問者が、2週間後にのみページBに訪問した。****

![](assets/time_between_after_operator.png)

**セグメント**&#x200B;の作成:このセグメントは、2つのヒットコンテナを持つ [!UICONTROL 訪問者] コンテナを追加することによっ [!UICONTROL て] 作成されます。これにより、[!UICONTROL THEN] 演算子を設定し、[!UICONTROL AFTER] 演算子のドロップダウンを展開して、週の数値を設定できます。

![](assets/after_operator.png)

**一致する場合**

「2 週間後」と指定した状態で、ページ A へのヒットが 2019 年 6 月 1 日の 0 時 1 分 に発生し、その後、次のページ B へのヒットが 2019 年 6 月 15 日の 0 時 1 分（14 日後）までに発生した場合。

| ヒット A | ヒット B | 一致 |
|--- |--- |--- |
| **A** ヒット：2019 年 6 月 1 日 0 時 1 分 | **B** ヒット：2019 年 6 月 15 日 0 時 1 分 | **一致:** この時間制限は、2019年6月1日（2週間）の後に一致します。 |
| **A** ヒット：2019 年 6 月 1 日 0 時 1 分 | **B** ヒット:2019年6月8日00:01Bヒット:2019年6月15日00:01 | **一致しない:** ページBの最初のヒットは、2週間後に要求される制約と矛盾するので、一致しません。 |

## Within演算子の使用

* [!UICONTROL Within] では、年、月、日、時間および分を指定して、一致する訪問を追跡できます。
* [!UICONTROL Within] は、このような細かな精度を定義できる唯一のレベルである[!UICONTROL ヒット]コンテナにのみ適用されます。

>[!IMPORTANT]
>
>「within」句の「THEN」ステートメントの間に、たとえば「within 1 search keyword instance（1 個の検索キーワードのインスタンス内）」や「within 1 eVar 47 instance（1 個の eVar 47 インスタンス内）」というように追加できます。これにより、ディメンションの 1 個のインスタンス内にセグメントが制限されます。

****&#x200B;例:ページAを訪問した後、5分以内にページBを訪問した訪問者。

![](assets/time_between_within_operator.png)

**セグメントの作成**:このセグメントは [!UICONTROL 、訪問者] コンテナを追加し、次に [!UICONTROL 2つのヒット] コンテナをドラッグして作成します。次に、[!UICONTROL THEN] 演算子を設定し、[!UICONTROL AFTER] 演算子のドロップダウンを展開して、間隔（ヒット、ページビュー、訪問、分、時、日、週、月、四半期または年）を設定できます。

![](assets/within_operator.png)

**一致する場合**

この時間制限以内に一致が発生する必要があります。この式では、訪問者がページAをヒットしたときに00:01が発生すると、次のページBへのヒットが00:06（5分後に同じ分を含む）に発生した場合に一致します。ちょうど指定した時間である場合も一致と見なされます。

## Within演算子とAfter演算子

[!UICONTROL Within] および [!UICONTROL After] は、セグメントの両端でエンドポイントの最大値と最小値を指定するために使用します。

****&#x200B;例:ページAを訪問した訪問者が、2週間後に、1か月以内にページBに訪問した。

![](assets/time_between_using_both_operators.png)

**セグメント**&#x200B;の作成:2 [!UICONTROL つのヒット] コンテナを [!UICONTROL 訪問者] コンテナ内に順に並べて、セグメントを作成します。次に、[!UICONTROL After] 演算子と [!UICONTROL Within] 演算子を設定します。

![](assets/within_after_together.png)

**一致する場合**

2019 年 6 月 1 日にページ A をヒットした後、2019 年 6 月 15 日 0 時 1 分より後、2019 年 7 月 1 日より前に戻った訪問者がこのセグメントに含まれます。**[間隔：「以下を除外する」](../../../components/c-segmentation/c-segmentation-workflow/seg-sequential-build.md#concept_C5CB0A391B7C4AC8A95B9724A14E28E8)と比較してください。

[!UICONTROL After] 演算子と [!UICONTROL Within] 演算子を一緒に使用して、順次セグメントを定義できます。

![](assets/time_between_within_after.png)

この例では、2 回目の訪問で 2 週間後から 1 か月までの間にページ B にヒットしています。
